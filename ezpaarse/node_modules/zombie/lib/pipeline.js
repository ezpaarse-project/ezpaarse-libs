'use strict';

var _inherits = require('babel-runtime/helpers/inherits')['default'];

var _get = require('babel-runtime/helpers/get')['default'];

var _createClass = require('babel-runtime/helpers/create-class')['default'];

var _classCallCheck = require('babel-runtime/helpers/class-call-check')['default'];

var _core = require('babel-runtime/core-js')['default'];

var _regeneratorRuntime = require('babel-runtime/regenerator')['default'];

var _ = require('lodash');
var assert = require('assert');
var Fetch = require('./fetch');
var File = require('fs');

var _require = require('./fetch');

var Headers = _require.Headers;

var _require2 = require('util');

var isArray = _require2.isArray;

var Path = require('path');
var Request = require('request');
var resourceLoader = require('jsdom/lib/jsdom/browser/resource-loader');
var URL = require('url');
var Utils = require('jsdom/lib/jsdom/utils');

// Pipeline is sequence of request/response handlers that are used to prepare a
// request, make the request, and process the response.

var Pipeline = (function (_Array) {
  function Pipeline(browser) {
    _classCallCheck(this, Pipeline);

    _get(_core.Object.getPrototypeOf(Pipeline.prototype), 'constructor', this).call(this);
    this._browser = browser;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = _core.getIterator(Pipeline._default), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var handler = _step.value;

        this.push(handler);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator['return']) {
          _iterator['return']();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  _inherits(Pipeline, _Array);

  _createClass(Pipeline, [{
    key: '_fetch',
    value: function _fetch(input, init) {
      var request, browser, response;
      return _regeneratorRuntime.async(function _fetch$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            request = new Fetch.Request(input, init);
            browser = this._browser;

            browser.emit('request', request);

            context$2$0.prev = 3;
            context$2$0.next = 6;
            return this._runPipeline(request);

          case 6:
            response = context$2$0.sent;

            response.time = _core.Date.now();
            response.request = request;
            browser.emit('response', request, response);
            return context$2$0.abrupt('return', response);

          case 13:
            context$2$0.prev = 13;
            context$2$0.t2 = context$2$0['catch'](3);

            browser._debug('Resource error', context$2$0.t2.stack);
            throw new TypeError(context$2$0.t2.message);

          case 17:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[3, 13]]);
    }
  }, {
    key: '_runPipeline',
    value: function _runPipeline(request) {
      var browser, requestHandlers, responseHandlers, response, _iteratorNormalCompletion2, _didIteratorError2, _iteratorError2, _iterator2, _step2, requestHandler, _iteratorNormalCompletion3, _didIteratorError3, _iteratorError3, _iterator3, _step3, responseHandler;

      return _regeneratorRuntime.async(function _runPipeline$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            browser = this._browser;
            requestHandlers = this.filter(function (fn) {
              return fn.length === 2;
            }).concat(Pipeline.makeHTTPRequest);
            responseHandlers = this.filter(function (fn) {
              return fn.length === 3;
            });
            response = undefined;
            _iteratorNormalCompletion2 = true;
            _didIteratorError2 = false;
            _iteratorError2 = undefined;
            context$2$0.prev = 7;
            _iterator2 = _core.getIterator(requestHandlers);

          case 9:
            if (_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done) {
              context$2$0.next = 19;
              break;
            }

            requestHandler = _step2.value;
            context$2$0.next = 13;
            return requestHandler(browser, request);

          case 13:
            response = context$2$0.sent;

            if (!response) {
              context$2$0.next = 16;
              break;
            }

            return context$2$0.abrupt('break', 19);

          case 16:
            _iteratorNormalCompletion2 = true;
            context$2$0.next = 9;
            break;

          case 19:
            context$2$0.next = 25;
            break;

          case 21:
            context$2$0.prev = 21;
            context$2$0.t3 = context$2$0['catch'](7);
            _didIteratorError2 = true;
            _iteratorError2 = context$2$0.t3;

          case 25:
            context$2$0.prev = 25;
            context$2$0.prev = 26;

            if (!_iteratorNormalCompletion2 && _iterator2['return']) {
              _iterator2['return']();
            }

          case 28:
            context$2$0.prev = 28;

            if (!_didIteratorError2) {
              context$2$0.next = 31;
              break;
            }

            throw _iteratorError2;

          case 31:
            return context$2$0.finish(28);

          case 32:
            return context$2$0.finish(25);

          case 33:
            _iteratorNormalCompletion3 = true;
            _didIteratorError3 = false;
            _iteratorError3 = undefined;
            context$2$0.prev = 36;
            _iterator3 = _core.getIterator(responseHandlers);

          case 38:
            if (_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done) {
              context$2$0.next = 47;
              break;
            }

            responseHandler = _step3.value;
            context$2$0.next = 42;
            return responseHandler(browser, request, response);

          case 42:
            response = context$2$0.sent;

            assert(response, 'Response handler must return a response');

          case 44:
            _iteratorNormalCompletion3 = true;
            context$2$0.next = 38;
            break;

          case 47:
            context$2$0.next = 53;
            break;

          case 49:
            context$2$0.prev = 49;
            context$2$0.t4 = context$2$0['catch'](36);
            _didIteratorError3 = true;
            _iteratorError3 = context$2$0.t4;

          case 53:
            context$2$0.prev = 53;
            context$2$0.prev = 54;

            if (!_iteratorNormalCompletion3 && _iterator3['return']) {
              _iterator3['return']();
            }

          case 56:
            context$2$0.prev = 56;

            if (!_didIteratorError3) {
              context$2$0.next = 59;
              break;
            }

            throw _iteratorError3;

          case 59:
            return context$2$0.finish(56);

          case 60:
            return context$2$0.finish(53);

          case 61:
            return context$2$0.abrupt('return', response);

          case 62:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this, [[7, 21, 25, 33], [26,, 28, 32], [36, 49, 53, 61], [54,, 56, 60]]);
    }
  }, {
    key: 'addHandler',

    // -- Handlers --

    // Add a request or response handler.  This handler will only be used by this
    // pipeline instance (browser).
    value: function addHandler(handler) {
      assert(handler.call, 'Handler must be a function');
      assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (reponse handler) arguments');
      this.push(handler);
    }
  }], [{
    key: 'addHandler',

    // Add a request or response handler.  This handler will be used by any new
    // pipeline instance (browser).
    value: function addHandler(handler) {
      assert(handler.call, 'Handler must be a function');
      assert(handler.length === 2 || handler.length === 3, 'Handler function takes 2 (request handler) or 3 (response handler) arguments');
      this._default.push(handler);
    }
  }, {
    key: 'normalizeURL',

    // -- Prepare request --

    // This handler normalizes the request URL.
    //
    // It turns relative URLs into absolute URLs based on the current document URL
    // or base element, or if no document open, based on browser.site property.
    value: function normalizeURL(browser, request) {
      if (browser.document)
        // Resolve URL relative to document URL/base, or for new browser, using
        // Browser.site
        request.url = resourceLoader.resolveResourceUrl(browser.document, request.url);else request.url = Utils.resolveHref(browser.site || 'http://localhost', request.url);
    }
  }, {
    key: 'mergeHeaders',

    // This handler mergers request headers.
    //
    // It combines headers provided in the request with custom headers defined by
    // the browser (user agent, authentication, etc).
    //
    // It also normalizes all headers by down-casing the header names.
    value: function mergeHeaders(browser, request) {
      if (browser.headers) _.each(browser.headers, function (value, name) {
        request.headers.append(name, browser.headers[name]);
      });
      if (!request.headers.has('User-Agent')) request.headers.set('User-Agent', browser.userAgent);

      // Always pass Host: from request URL

      var _URL$parse = URL.parse(request.url);

      var host = _URL$parse.host;

      request.headers.set('Host', host);

      // HTTP Basic authentication
      var authenticate = { host: host, username: null, password: null };
      browser.emit('authenticate', authenticate);
      var username = authenticate.username;
      var password = authenticate.password;

      if (username && password) {
        browser.log('Authenticating as ' + username + ':' + password);
        var base64 = new Buffer('' + username + ':' + password).toString('base64');
        request.headers.set('authorization', 'Basic ' + base64);
      }
    }
  }, {
    key: 'makeHTTPRequest',

    // -- Retrieve actualy resource --

    // Used to perform HTTP request (also supports file: resources).  This is always
    // the last request handler.
    value: function makeHTTPRequest(browser, request) {
      var url, _URL$parse2, protocol, hostname, pathname, filename, exists, stream, _ret;

      return _regeneratorRuntime.async(function makeHTTPRequest$(context$2$0) {
        var _this = this;

        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            url = request.url;
            _URL$parse2 = URL.parse(url);
            protocol = _URL$parse2.protocol;
            hostname = _URL$parse2.hostname;
            pathname = _URL$parse2.pathname;

            if (!(protocol === 'file:')) {
              context$2$0.next = 18;
              break;
            }

            if (!(request.method !== 'GET')) {
              context$2$0.next = 8;
              break;
            }

            return context$2$0.abrupt('return', new Fetch.Response('', { url: url, status: 405 }));

          case 8:
            filename = Path.normalize(decodeURI(pathname));
            exists = File.existsSync(filename);

            if (!exists) {
              context$2$0.next = 15;
              break;
            }

            stream = File.createReadStream(filename);
            return context$2$0.abrupt('return', new Fetch.Response(stream, { url: url, status: 200 }));

          case 15:
            return context$2$0.abrupt('return', new Fetch.Response('', { url: url, status: 404 }));

          case 16:
            context$2$0.next = 23;
            break;

          case 18:
            context$2$0.next = 20;
            return (function callee$2$0() {
              var cookies, cookieHeader, buffer, httpRequest;
              return _regeneratorRuntime.async(function callee$2$0$(context$3$0) {
                while (1) switch (context$3$0.prev = context$3$0.next) {
                  case 0:
                    cookies = browser.cookies;
                    cookieHeader = cookies.serialize(hostname, pathname);

                    if (cookieHeader) request.headers.append('Cookie', cookieHeader);

                    if (!/^GET|HEAD$/.test(request.method)) {
                      context$3$0.next = 7;
                      break;
                    }

                    context$3$0.t5 = null;
                    context$3$0.next = 10;
                    break;

                  case 7:
                    context$3$0.next = 9;
                    return request._consume();

                  case 9:
                    context$3$0.t5 = context$3$0.sent;

                  case 10:
                    buffer = context$3$0.t5;
                    httpRequest = new Request({
                      method: request.method,
                      uri: request.url,
                      headers: request.headers.toObject(),
                      proxy: browser.proxy,
                      body: buffer,
                      jar: false,
                      followRedirect: false,
                      strictSSL: browser.strictSSL,
                      localAddress: browser.localAddress || 0
                    });
                    context$3$0.next = 14;
                    return new _core.Promise(function (resolve, reject) {
                      httpRequest.on('response', function (response) {
                        // Request returns an object where property name is header name,
                        // property value is either header value, or an array if header sent
                        // multiple times (e.g. `Set-Cookie`).
                        var arrayOfHeaders = _.reduce(response.headers, function (headers, value, name) {
                          if (isArray(value)) {
                            var _iteratorNormalCompletion4 = true;
                            var _didIteratorError4 = false;
                            var _iteratorError4 = undefined;

                            try {
                              for (var _iterator4 = _core.getIterator(value), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                                var item = _step4.value;

                                headers.push([name, item]);
                              }
                            } catch (err) {
                              _didIteratorError4 = true;
                              _iteratorError4 = err;
                            } finally {
                              try {
                                if (!_iteratorNormalCompletion4 && _iterator4['return']) {
                                  _iterator4['return']();
                                }
                              } finally {
                                if (_didIteratorError4) {
                                  throw _iteratorError4;
                                }
                              }
                            }
                          } else headers.push([name, value]);
                          return headers;
                        }, []);

                        resolve(new Fetch.Response(response, {
                          url: request.url,
                          status: response.statusCode,
                          headers: new Headers(arrayOfHeaders)
                        }));
                      }).on('error', reject);
                    });

                  case 14:
                    context$3$0.t6 = context$3$0.sent;
                    return context$3$0.abrupt('return', {
                      v: context$3$0.t6
                    });

                  case 16:
                  case 'end':
                    return context$3$0.stop();
                }
              }, null, _this);
            })();

          case 20:
            _ret = context$2$0.sent;

            if (!(typeof _ret === 'object')) {
              context$2$0.next = 23;
              break;
            }

            return context$2$0.abrupt('return', _ret.v);

          case 23:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }, {
    key: 'handleHeaders',

    // -- Handle response --

    value: function handleHeaders(browser, request, response) {
      response.headers = new Headers(response.headers);
      return response;
    }
  }, {
    key: 'handleCookies',
    value: function handleCookies(browser, request, response) {
      // Set cookies from response: call update() with array of headers

      var _URL$parse3 = URL.parse(request.url);

      var hostname = _URL$parse3.hostname;
      var pathname = _URL$parse3.pathname;

      var newCookies = response.headers.getAll('Set-Cookie');
      browser.cookies.update(newCookies, hostname, pathname);
      return response;
    }
  }, {
    key: 'handleRedirect',
    value: function handleRedirect(browser, request, response) {
      var status, _location;

      return _regeneratorRuntime.async(function handleRedirect$(context$2$0) {
        while (1) switch (context$2$0.prev = context$2$0.next) {
          case 0:
            status = response.status;

            if (!(status === 301 || status === 302 || status === 303 || status === 307 || status === 308)) {
              context$2$0.next = 19;
              break;
            }

            if (!(request.redirect === 'error')) {
              context$2$0.next = 4;
              break;
            }

            return context$2$0.abrupt('return', Fetch.Response.error());

          case 4:
            _location = response.headers.get('Location');

            if (!(_location === null)) {
              context$2$0.next = 7;
              break;
            }

            return context$2$0.abrupt('return', response);

          case 7:
            if (!(request._redirectCount >= 20)) {
              context$2$0.next = 9;
              break;
            }

            return context$2$0.abrupt('return', Fetch.Response.error());

          case 9:

            browser.emit('redirect', request, response, _location);
            ++request._redirectCount;
            if (status !== 307) {
              request.method = 'GET';
              request.headers['delete']('Content-Type');
              request.headers['delete']('Content-Length');
              request.headers['delete']('Content-Transfer-Encoding');
            }

            // This request is referer for next
            request.headers.set('Referer', request.url);
            request.url = Utils.resolveHref(request.url, _location);
            context$2$0.next = 16;
            return browser.pipeline._runPipeline(request);

          case 16:
            return context$2$0.abrupt('return', context$2$0.sent);

          case 19:
            return context$2$0.abrupt('return', response);

          case 20:
          case 'end':
            return context$2$0.stop();
        }
      }, null, this);
    }
  }]);

  return Pipeline;
})(Array);

// The default pipeline.  All new pipelines are instantiated with this set of
// handlers.
Pipeline._default = [Pipeline.normalizeURL, Pipeline.mergeHeaders, Pipeline.handleHeaders, Pipeline.handleCookies, Pipeline.handleRedirect];

module.exports = Pipeline;

// If the request is for a file:// descriptor, just open directly from the
// file system rather than getting node's http (which handles file://
// poorly) involved.

// We're going to use cookies later when recieving response.
//# sourceMappingURL=pipeline.js.map